const currentPath = window.location.pathname;

document.addEventListener('DOMContentLoaded', function() {

    const links = document.querySelectorAll('.sidebar ul a');

    // Function to check if the current path is part of the link's path
    const isLinkActive = (link, currentPath) => {
      const href = link.getAttribute('href');
      return currentPath.startsWith(href);
    };
    
    // adds active to the path we're in
    links.forEach(link => {
      const href = link.getAttribute('href');

      // adds active to the main pages and their children
      if (isLinkActive(link, currentPath) && href !== '/') {
        link.classList.add('active');
      }
      
      // adds active to the settings pages
      if (isLinkActive(link, currentPath) && href !== '/') {
        if(link.getAttribute('href').split('/')[1] == 'settings') {
            const settings_link = document.querySelector('.sidebar ul a[href*="/settings/account"]')
            settings_link.classList.add('active');
        }
      }
    });
    
    
    

    // const currentPath = window.location.pathname;
    // If the path starts with settings then collapse the main sidebar
    if(currentPath.split('/')[1] == 'settings') {
        const logo = document.querySelector('.sidebar .logo');
        const nav_texts = document.querySelectorAll('.sidebar-main p');
        const sidebar = document.querySelector('.sidebar-main');
        const nav_list_items = document.querySelectorAll('.sidebar-main li');
        const settings_sidebar = document.querySelector('.settings-sidebar');
        const header = document.querySelector('.settings-sidebar + header');
        const settings_wrapper = document.querySelector('.settings-wrapper');
        if(currentPath == '/settings/') {
            logo.style.transition = 'height 1s ease-in-out, opacity 1s ease-in-out';
            nav_texts.forEach(nav_text => {
                nav_text.style.transition = 'opacity 1s ease-in-out';
            });
            sidebar.style.transition = 'width 1s ease-in-out, padding-top 1s ease-in-out';
            nav_list_items.forEach(nav_list_item => {
                nav_list_item.style.transition = 'padding 1s ease-in-out, margin-bottom 1s ease-in-out';
            });
            settings_sidebar.style.transition = 'margin-left 1s ease-in-out';
            header.style.transition = 'margin-left 1s ease-in-out';
            settings_wrapper.style.transition = 'margin-left 1s ease-in-out';
        }
        var timeout;
        if (currentPath.split('/')[2]) {
            timeout = 0;
            side_bar_styling(timeout, logo, nav_texts, sidebar, nav_list_items, settings_sidebar, header, settings_wrapper);
        } else {
            timeout = 500;
            side_bar_styling(timeout, logo, nav_texts, sidebar, nav_list_items, settings_sidebar, header, settings_wrapper);
        }
    }
    
    function side_bar_styling(timeout, logo, nav_texts, sidebar, nav_list_items, settings_sidebar, header, settings_wrapper) {
        setTimeout(() => {
            logo.style.opacity = '0';
            setTimeout(() => {
                logo.style.height = '0';                
            }, timeout);
            logo.style.overflow = 'hidden';
            nav_texts.forEach(nav_text => {
                nav_text.style.opacity = '0';
                nav_text.style.overflow = 'hidden';
            });
            sidebar.style.width = '80px'
            sidebar.style.paddingTop = '0';
            nav_list_items.forEach(nav_list_item => {
                nav_list_item.style.paddingLeft = '10px';
                nav_list_item.style.paddingRight = '10px';
                nav_list_item.style.paddingTop = '10px';
                nav_list_item.style.paddingBottom = '10px';
                nav_list_item.style.marginBottom = '0';
            })
            settings_sidebar.style.marginLeft = '100px';
            header.style.marginLeft = 30+220+10+100+'px';
            settings_wrapper.style.marginLeft = 30+220+10+100+'px';
        }, timeout);
    }


    // Find loader
    const loader = document.querySelector('.loader-container');
    if(loader) {
        setTimeout(() => {
            loader.style.display = 'none';        
        }, 250);
    }

});
document.addEventListener("DOMContentLoaded", function () {
    const tables = document.querySelectorAll('.table-sort');
    let ascending = true;
    
    if (tables.length > 0) {
        tables.forEach(table => {
            const headers = table.querySelectorAll("th[data-sort]");
            
            headers.forEach(header => {
                header.addEventListener("click", async function () {
                    const column = header.getAttribute("data-sort");
                    const sortOrder = ascending ? 'asc' : 'desc';

                    const link = parseUrlPath(window.location.href);

                    // Get the current page from the pagination links
                    const currentPageLink = document.querySelector('.pagination a[data-current-page]');
                    const currentPage = currentPageLink ? Number(currentPageLink.getAttribute('data-current-page')) : 1;

                    // Perform an AJAX request to fetch sorted data
                    const response = await fetch(`${link[0]}/sort?page=${currentPage}&sort_by=${column}&sort_order=${sortOrder}&reload=false`);
                    const sortedData = await response.json();

                    // Clear the current table body
                    const tbody = table.querySelector("tbody");
                    tbody.innerHTML = ''; // Clear existing rows

                    // Get header fields from the current table
                    const headerFields = Array.from(headers).map(header => ({
                        field: header.getAttribute("data-field"),
                        link: header.getAttribute("data-link"),
                        prefix: header.getAttribute("data-prefix"),
                        separator: header.getAttribute("data-separator"),
                        extra: header.getAttribute("data-extra"),
                        placement: header.getAttribute("data-extra-placement"),
                        space: header.getAttribute("data-extra-space"),
                    }));

                    // Populate the table with dynamic data
                    sortedData.data.forEach(dataRow => {
                        const row = document.createElement('tr');

                        // Add checkbox as the first column
                        const checkboxCell = document.createElement('td');
                        checkboxCell.innerHTML = `
                            <label class="checkbox">
                                <input type="checkbox" class="invoice-checkbox box-checkbox" data-id="${dataRow._id}">
                            </label>
                        `;
                        row.appendChild(checkboxCell); // Append checkbox cell as first column

                        // Populate the rest of the columns dynamically
                        headerFields.forEach(header => {
                            if (header.field !== 'checkbox') {
                                const cell = document.createElement('td');
                                
                                // If the field is 'number', include prefix and separator
                                if (header.field === 'number' && header.prefix && header.separator) {
                                    const prefix = getNestedValue(dataRow, header.prefix);
                                    const separator = getNestedValue(dataRow, header.separator);
                                    
                                    cell.innerHTML = `<a class="link" href="${link[0]}${header.link}${dataRow._id}">${prefix}${separator}${getNestedValue(dataRow, header.field)}</a>`;
                                } else if (header.link) {
                                    cell.innerHTML = `<a class="link" href="${link[0]}${header.link}${dataRow._id}">${getNestedValue(dataRow, header.field)}</a>`;
                                } else {
                                    const fieldValue = getNestedValue(dataRow, header.field, header.extra, header.placement, header.space); // Dynamically get value from the data
                                    cell.innerHTML = fieldValue !== undefined ? fieldValue : '';
                                }

                                row.appendChild(cell);
                            }
                        });

                        tbody.appendChild(row);
                    });

                    // Toggle sort direction for the next click
                    ascending = !ascending;

                    // Update pagination links (if needed)
                    updatePaginationLinks(currentPage, column, sortOrder, link);
                });
            });
        });
    }

    function updatePaginationLinks(currentPage, column, sortOrder, link) {
        const previousLink = document.querySelector('.pagination .previous');
        const nextLink = document.querySelector('.pagination .next');
    
        if (previousLink) {
            previousLink.href = `${link[0]}/sort?page=${Number(currentPage) - 1}&sort_by=${column}&sort_order=${sortOrder}&reload=true`;
        }
        if (nextLink) {
            nextLink.href = `${link[0]}/sort?page=${Number(currentPage) + 1}&sort_by=${column}&sort_order=${sortOrder}&reload=true`;
        }
    }

    function parseUrlPath(link) {
        const url = new URL(link);
        const pathname = url.pathname;
        const pathParts = pathname.split('/').filter(Boolean);
        const isSort = pathParts.includes('sort');
        let mainPath = isSort ? '/' + pathParts.slice(0, pathParts.indexOf('sort')).join('/') : '/' + pathParts.join('/');
        const searchPart = isSort ? '/sort' + url.search : '';
        return searchPart ? [mainPath, searchPart] : [mainPath];
    }

    function getNestedValue(obj, path, path_extra, placement, space) {
        // Retrieve the main value using the path
        const mainValue = path.split('.').reduce((value, key) => value && value[key], obj);
    
        // If there's an extra path, retrieve that value as well
        if (path_extra) {
            const extraValue = path_extra.split('.').reduce((value, key) => value && value[key], obj);
            if (placement == "before") {
                if (space === "true") {
                    return extraValue + " " + mainValue;
                } else {
                    return extraValue + mainValue;
                }
            } else {
                if (space === "true") {
                    return mainValue + " " + extraValue;
                } else {
                    return mainValue + extraValue;
                }
            }
        }
    
        // Return only the main value if no extra path is provided
        return mainValue;
    }    
});

function checkAllBoxes(input) {
    // Select all checkboxes with the class 'box-checkbox'
    const checkboxes = document.querySelectorAll('.box-checkbox');

    // Loop through each checkbox and set its 'checked' property
    checkboxes.forEach((checkbox) => {
        checkbox.checked = input.checked;
    });
}
// Initially hide rows beyond the fifth
const number_per_page = 5 + 1; // don't change the + 1
document.addEventListener("DOMContentLoaded", function() {
    const tables = document.querySelectorAll(".dataTable");
    if (tables) {
        tables.forEach(table => {
            const rows = table.getElementsByTagName("tr");

            if (rows.length > number_per_page) {
                table.parentNode.querySelector('.toggleButton').classList.remove('hidden');
            }

            for (let i = number_per_page; i < rows.length; i++) {
                rows[i].classList.add("hidden");
            }
        })
    }
});

// Function to toggle the collapse state
function toggleCollapse(buttonEl) {
    const table = buttonEl.parentNode.querySelector('.dataTable');
    const rows = table.getElementsByTagName("tr");

    // Check if the first hidden row is already hidden
    const isHidden = rows[number_per_page].classList.contains("hidden");

    // Toggle visibility of rows beyond the fifth
    for (let i = number_per_page; i < rows.length; i++) {
        rows[i].classList.toggle("hidden", !isHidden);
    }

    // Update button text based on current state
    const button = table.parentNode.querySelector('.toggleButton');
    button.textContent = isHidden ? "Show Less" : "Show More";
}

function shippingCheckBoxChange(checkbox) {
    const shippingDetailsSection = document.querySelector('.shipping_details');

    if (checkbox.checked) {
        // If "Same as shipping information" is checked
        shippingDetailsSection.classList.add('hidden');
    } else {
        // If "Same as shipping information" is unchecked
        shippingDetailsSection.classList.remove('hidden');
    }
}


function deleteSelectedCustomers() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.customer-checkbox:checked');

    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/customers/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Customers deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}
var dataLists;

function getDataLists() {

    // Get all elements with class "data-list"
    dataLists = document.querySelectorAll('.data-list');
    // Iterate over each data list
    dataLists.forEach(dataList => {
        createDataList(dataList);
    });

}

getDataLists();

function createDataList(dataList) {
    // Find the associated input element within the current data list
    const input = dataList.querySelector('.data-list-input');
    const datalist = dataList.querySelector('.data-list-datalist');

    if (!input || !datalist) {
        logger.error('Input or datalist element not found for data list.');
        return;
    }

    // Click event listener to hide datalist when clicking outside the input and datalist
    document.addEventListener('click', function (event) {
        const isClickInsideInput = input.contains(event.target);
        const isClickInsideDatalist = datalist.contains(event.target);


        if (!isClickInsideInput && !isClickInsideDatalist) {
            datalist.style.display = 'none';
            input.style.borderRadius = "5px";
        }
    });

    // Focus event for the input field
    input.onfocus = function () {
        datalist.style.display = 'block';
        input.style.borderRadius = "5px 5px 0 0";
    };

    clickOptions(input, datalist);

    // Initialize the currentFocus
    var currentFocus = -1;
    // Input event for filtering options based on user input
    input.oninput = function () {
        // reset the current focus to 0 when input has changed
        currentFocus = -1;
        const text = input.value.toUpperCase();
        const options = datalist.querySelectorAll('option');

        for (let option of options) {
            if (option.value.toUpperCase().indexOf(text) > -1) {
                option.style.display = "block";
            } else {
                option.style.display = "none";
            }
        }
    }

    // Keydown event for handling arrow key navigation, Enter key, and Backspace key
    input.onkeydown = function (e) {
        if (e.keyCode == 40 || e.keyCode == 38) {
            // Arrow down or Arrow up key pressed
            const visibleOptions = getVisibleOptions(datalist);
            if (e.keyCode == 40) {
                // Arrow down key pressed
                currentFocus += 1;
                if(currentFocus > visibleOptions.length) {
                    currentFocus = 1;
                }
                addActive(visibleOptions, currentFocus);
            } else if (e.keyCode == 38) {
                // Arrow up key pressed
                currentFocus -= 1;
                if(currentFocus < 1) {
                    currentFocus = visibleOptions.length;
                }
                addActive(visibleOptions, currentFocus);
            }
        } else if (e.keyCode == 13) {
            // Enter key pressed
            e.preventDefault();
            const activeOption = datalist.querySelector('.active');

            if (activeOption) {
                input.value = activeOption.value;
                datalist.style.display = 'none';
                input.style.borderRadius = '5px';
                const selectedOption = datalist.querySelector('.selected');
                if(selectedOption) {
                    selectedOption.classList.remove('selected');
                }
                activeOption.classList.add('selected');
                triggerInvoiceChange(activeOption);
            }
        } else if (e.keyCode == 8) {
            // Backspace key pressed
            removeActive(datalist.querySelectorAll('option'));
            datalist.style.display = 'block';
        }
    };
}

// Helper function to filter visible options
function getVisibleOptions(datalist) {
    return Array.from(datalist.querySelectorAll('option')).filter(option => option.style.display !== 'none');
}

// Helper function to add active class to the currently focused option
function addActive(options, currentFocus) {
    if (!options || !options.length) return false;

    removeActive(options);
    currentFocus = (currentFocus + options.length) % options.length;  // Ensure a valid index

    options[currentFocus].classList.add("active");
}

// Helper function to remove active class from all options
function removeActive(options) {
    options.forEach(option => option.classList.remove("active"));
}

// Helper function to get the current focus index
function getCurrentFocus(datalist) {
    const activeOption = datalist.querySelector('.active');
    return activeOption ? Array.from(datalist.querySelectorAll('option')).indexOf(activeOption) : -1;
}

// Trigger the change on the invoice page, this is to change the shipping, vat, discount and total values
function triggerInvoiceChange(option) {
    const invoicePage = document.querySelector(".create-invoice");
    if(invoicePage) {
        changeInvoice(option);
    }
}

function clickOptions(input, datalist) {
    // Click event for datalist options
    for (let option of datalist.options) {
        option.onclick = function () {
            input.value = option.value;
            datalist.style.display = 'none';
            input.style.borderRadius = "5px";
            // Add a selected class to the option selected and remove the previous one if there is any
            const selectedOption = option.parentNode.querySelector('.selected');
            if(selectedOption) {
                selectedOption.classList.remove('selected');
            }
            option.classList.add('selected');
            // Trigger the invoice change
            triggerInvoiceChange(option);
        }
    };
}
function deleteSelectedDiscounts() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.discount-checkbox:checked');

    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/settings/discounts/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Discounts deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}
const paid_on = document.getElementById('paid_on');
if(paid_on) {
    // Get the current date in the format YYYY-MM-DD
    const currentDate = new Date().toISOString().split('T')[0];

    // Set the value of the input element to the current date
    paid_on.value = currentDate;
}
  
function deleteSelectedInvoices() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.invoice-checkbox:checked');

    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/invoices/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Invoices deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}


// JavaScript function to clone and append the element
function addElement(container) {
    // Get the template element within the specified container
    const template = container.querySelector('.add-el');

    // Clone the template element
    const clone = template.cloneNode(true);

    // Update the 'for' attribute of the label
    const label = clone.querySelector('.data-list-label')
    const labelFor = label.getAttribute('for');
    const labelNumber = container.querySelectorAll('.add-el').length + 1;
    label.setAttribute('for', `${labelFor}-${labelNumber}`);

    // Update the 'id' attribute of the input before the datalist
    const inputBeforeDatalist = clone.querySelector('.data-list-input');
    const inputIdBeforeDatalist = inputBeforeDatalist.getAttribute('id');
    inputBeforeDatalist.setAttribute('id', `${inputIdBeforeDatalist}-${labelNumber}`);

    // Update the 'id' attribute of the datalist
    const datalist = clone.querySelector('.data-list-datalist');
    const datalistId = datalist.getAttribute('id');
    datalist.setAttribute('id', `${datalistId}-${labelNumber}`);

    // Clear the input values in the clone
    const inputs = clone.querySelectorAll('input');
    inputs.forEach(input => input.value = '');

    // Set the product quantities clone to value 1
    const product_quantites = clone.querySelector('input[name="product_quantities[]"]');
    if (product_quantites) {
        product_quantites.value = '1';
    }

    // Set the value of the input element with name "paid_on" to today
    const paid_on = clone.querySelector('input[name="paid_on[]"]');
    if(paid_on) {
        const today = new Date().toISOString().split('T')[0];
        paid_on.value = today;
    } 
    
    // Append the clone to the container
    container.querySelector('.add-el-container').appendChild(clone);
    getDataLists();
}



async function createInvoice() {
    const invoiceForm = document.querySelector('form[action="/invoices/create"]');

    if (invoiceForm) {
        const formData = new FormData(invoiceForm);
        const dataIds = {};
        var prices = {};
        const discountAmounts = {}; // Change variable name to discountAmounts
    
        // Iterate over inputs with datalist
        const inputsWithDatalist = invoiceForm.querySelectorAll('.data-list-input');
        inputsWithDatalist.forEach((input) => {
            const datalistId = input.getAttribute('data-datalist-id');
            const datalist = document.querySelector(`#${datalistId}`);
            if (datalist) {
                const selectedOption = datalist.querySelector(`option[value="${input.value}"]`);
        
                // Append data-id, price, amount-total, amount-percentage, and tax-percentage to FormData if an option is selected
                if (selectedOption) {
                    formData.delete(input.name);
                    const dataId = selectedOption.getAttribute('data-id');
                    const price = selectedOption.getAttribute('data-price');
                    const amountTotal = selectedOption.getAttribute('data-amount-total');
                    const amountPercentage = selectedOption.getAttribute('data-amount-percentage');
                    const taxPercentage = selectedOption.getAttribute('data-percentage'); // Added line
        
                    // Check the type of input and store data accordingly
                    const inputType = input.name.replace(/\[\]$/, ''); // Remove trailing []
                    if (!dataIds[inputType]) {
                        dataIds[inputType] = [];
                    }
                    dataIds[inputType].push(dataId);
        
                    if (inputType.includes('product')) {
                        if (!prices[inputType]) {
                            prices[inputType] = [];
                        }
                        prices[inputType].push(price);
        
                        // Set each price individually in the form data
                        prices[inputType].forEach((productPrice, index) => {
                            formData.set(`${inputType}_prices[${index}]`, productPrice);
                        });
                    } else if (inputType.includes('discount')) {
                        if (!discountAmounts[inputType]) {
                            discountAmounts[inputType] = { total: [], percentage: [] };
                        }
                        discountAmounts[inputType].total.push(amountTotal);
                        discountAmounts[inputType].percentage.push(amountPercentage);
        
                        // Set each amount individually in the form data
                        discountAmounts[inputType].total.forEach((total, index) => {
                            formData.set(`${inputType}_amounts_totals[${index}]`, total);
                        });
        
                        // Set each amount percentage individually in the form data
                        discountAmounts[inputType].percentage.forEach((percentage, index) => {
                            formData.set(`${inputType}_amounts_percentages[${index}]`, percentage);
                        });
                    }
        
                    // Set tax percentage in the form data
                    formData.set(`${inputType}_tax_percentage`, taxPercentage);
        
                    // Set each dataId individually in the form data
                    dataIds[inputType].forEach((id, index) => {
                        formData.set(`${inputType}[${index}]`, id);
                    });
                }
            }
        });

        // Get the totals info
        const amount_total = parseFloat(document.querySelector('.total_amount').innerHTML);
        const amount_due = parseFloat(document.querySelector('.amount_due').innerHTML);

        // Get the project info
        const selected_project = document.getElementById('project-datalist').querySelector('.selected');
        let project_total_time;
        let project_hour_rate;
        let project_timeTracking;
        let project_name;
        let project_description; 
        if (selected_project) {
            project_total_time = selected_project.dataset.project_total_time;
            project_hour_rate = parseFloat(document.getElementById('project_hour_rate').value);
            project_timeTracking = JSON.stringify(JSON.parse(selected_project.dataset.time_tracking));
            project_name = document.getElementById('project').value;
            project_description = selected_project.dataset.description;
        }

        const tax_amount = parseFloat(document.querySelector('.total_tax').dataset.tax);

        // Create a new URLSearchParams object with the form data
        const formDataParams = new URLSearchParams(formData);
        // Append amount info and project info to the form data
        formDataParams.append('amount_total', amount_total);
        formDataParams.append('amount_due', amount_due);
        formDataParams.append('tax_amount', tax_amount);
        if (selected_project) {
            formDataParams.append('project_total_time', project_total_time);
            formDataParams.append('project_hour_rate', project_hour_rate);
            formDataParams.append('project_timeTracking', project_timeTracking);
            formDataParams.append('project_name', project_name);
            formDataParams.append('project_description', project_description);
        }


        // Fetch API POST request
        try {
            const response = await fetch('/invoices/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: formDataParams.toString(),
            });

            if (response.ok) {
                // Handle success, e.g., redirect to a new page
                window.location.href = '/invoices?success';
            } else {
                // Handle errors
                logger.error('Error:', response.statusText);
            }
        } catch (error) {
            logger.error('Error:', error.message);
        }
    }
}

// Attach the createInvoice function to the form submission event
const invoiceForm = document.querySelector('form[action="/invoices/create"]');
if (invoiceForm) {
    invoiceForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent the default form submission
        createInvoice(); // Call the custom function to handle form submission
    });

    // Set the value of the input element with name "paid_on" to today
    const today = new Date().toISOString().split('T')[0];
    document.querySelector('input[name="paid_on[]"]').value = today;
}


// Update the invoice totals
function changeInvoice (option) {
    // If the customer option has been selected then we need to search for the projects which match the customer
    if (option && option.classList.contains('customer-option')) {
        // Execute your code here
        getProjects(option);
    }

    const selectedOptions = document.querySelectorAll('.selected');

    // Get the product prices
    const prices = [];
    selectedOptions.forEach((option) => {
        const price = option.dataset.price;
        if (price !== undefined) {
            prices.push(parseFloat(price)); // Convert to a numeric value if needed
        }
    });

    // Get the product quantities
    const product_quantities_inputs = document.querySelectorAll('.product-quantity');
    const product_quantities = [];
    product_quantities_inputs.forEach((quantity) => {
        if (quantity.value !== undefined) {
            product_quantities.push(parseFloat(quantity.value));
        }
    })

    // Get the product totals
    const product_totals = [];
    for (let i = 0; i < prices.length; i++) {
        const product_total = prices[i] * product_quantities[i];
        product_totals.push(parseFloat(product_total));
    }

    // Get the discount percentage
    const discount_percentages = [];
    selectedOptions.forEach((option) => {
        const discount_percentage = option.dataset.amountPercentage;
        if (discount_percentage !== undefined) {
            discount_percentages.push(parseFloat(discount_percentage)); // Convert to a numeric value if needed
        }
    });


    // Get the discount percentage
    const discount_totals = [];
    selectedOptions.forEach((option) => {
        const discount_total = option.dataset.amountTotal;
        if (discount_total !== undefined) {
            discount_totals.push(parseFloat(discount_total)); // Convert to a numeric value if needed
        }
    });

    // Get the tax percentage
    const tax_percentage_input = document.querySelector('#tax-datalist .selected')
    var tax_percentage;
    if(tax_percentage_input) {
        tax_percentage = tax_percentage_input.dataset.percentage;
    }
    tax_percentage_input.setAttribute('data-tax-percentage', tax_percentage);

    // Get the shipping amount
    var shipping_amount = 0;
    if(document.querySelector('#shipping_amount').value) {
        shipping_amount = parseFloat(document.querySelector('#shipping_amount').value);
    }

    // Get the paid amounts
    const paid_amounts = [];
    const paid_amounts_input = document.querySelectorAll('.paid-amount');
    paid_amounts_input.forEach((amount) => {
        const paid_amount = amount.value;
        if (paid_amount !== undefined) {
            paid_amounts.push(parseFloat(paid_amount));
        }
    })


    // Get project total
    let project_total = 0;
    const project_total_data = document.querySelector('.total_project').dataset.total;
    if (project_total_data) {
        project_total = parseFloat(project_total_data);
    }

    // Calculate the totals
    const product_total = product_totals.reduce((sum, price) => sum + parseFloat(price), 0);
    const discount_amounts_total = discount_totals.reduce((sum, total) => sum + parseFloat(total),0);
    const discount_amounts_percentage = discount_percentages.reduce((sum, percentage) => sum + parseFloat(percentage),0);
    const sub_total = product_total + project_total;
    const discounts_total = (sub_total / 100 * discount_amounts_percentage) + discount_amounts_total;
    let tax_amount = ((sub_total - discounts_total) + shipping_amount) / 100 * parseFloat(tax_percentage);
    let amount_total = (product_total + project_total) - discounts_total + shipping_amount + tax_amount;
    const paid_total = paid_amounts.reduce((sum, amount) => sum + (parseFloat(amount) || 0), 0);
    const amount_due = (paid_total > amount_total) ? 0 : (amount_total - paid_total);

    // Update the totals
    document.querySelector('.total_products').innerHTML = (product_total).toFixed(2);
    document.querySelector('.total_products').setAttribute('data-total', (product_total).toFixed(2));
    document.querySelector('.total_shipping').innerHTML = (shipping_amount).toFixed(2);
    document.querySelector('.total_shipping').setAttribute('data-total', (shipping_amount).toFixed(2));
    document.querySelector('.total_discount').innerHTML = (discounts_total).toFixed(2);
    document.querySelector('.total_discount').setAttribute('data-total', (discounts_total).toFixed(2));
    document.querySelector('.total_tax').innerHTML = (tax_amount).toFixed(2) + " (" + tax_percentage + "%)";
    document.querySelector('.total_tax').setAttribute('data-tax', (tax_amount).toFixed(2));
    document.querySelector('.total_amount').innerHTML = (amount_total).toFixed(2);
    document.querySelector('.total_amount').setAttribute('data-total', (amount_total).toFixed(2));
    document.querySelector('.amount_due').innerHTML = (amount_due).toFixed(2);
    document.querySelector('.amount_due').setAttribute('data-total', (amount_due).toFixed(2));
}



function getProjects(option) {
    // Get the selected customer id
    const selectedCustomerId = option.dataset.id;
    // Send a GET request with the selected data-ids
    fetch(`/invoices/create/projects/${selectedCustomerId}`, {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
    })
    .then(response => {
        // Check if the response status is OK
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        // Parse the JSON response
        return response.json();
    })
    .then(response => {
        // Get the projects response
        const projects = response;

        // Get the project billing div
        const projectBilling = document.querySelector('.project-billing');

        // If the projects array isn't empty then remove the hidden class from the project billing div
        // When selecting another option where the projects are empty then add the hidden class again
        if (projects.length > 0) {
            projectBilling.classList.remove('hidden');
        } else {
            projectBilling.classList.add('hidden');
        }

        const input = document.getElementById('project');
        const datalist = document.getElementById('project-datalist');

        // Get the project input field
        const projectInput = document.getElementById('project');
        const projectDataList = document.getElementById('project-datalist');
        
        // Clear existing options
        projectInput.innerHTML = '';
        projectDataList.innerHTML = '';

        // Populate the datalist with the fetched projects
        projects.forEach(project => {
            const option = document.createElement('option');
            option.value = project.name;
            option.innerHTML = project.name;
            option.setAttribute('data-id', project._id);
            projectDataList.appendChild(option);
            option.setAttribute('data-time_tracking', JSON.stringify(project.timeTracking));
            option.setAttribute('data-description', project.description);
            option.setAttribute('data-project_total_time', project.totalTimeInHours)
        });
        clickOptions(input, datalist);
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}

function updatePriceWithProject(el) {
    // Get the hour rate applied
    hourRate = el.value;
    // Get the project ID
    const project_id = document.getElementById("project-datalist").querySelector('.selected').dataset.id;
    // If there's no hour rate, update the according totals
    if (!hourRate) {
        // Select the <p> element with class "total_project"
        const totalProjectElement = document.querySelector('.total_project');
        // Reset the project total
        totalProjectElement.innerHTML = "";
        // Update the value of the data-total attribute to 0
        totalProjectElement.dataset.total = '0';
        // Recalculate the totals
        changeInvoice();
        return;
    }
    fetch(`/invoices/create//project/${project_id}/${hourRate}`, {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
    })
    .then(response => {
        // Check if the response status is OK
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }

        // Parse the JSON response
        return response.json();
    })
    .then(response => {
        // Get the projects response
        const projectPrice = response;

        // Update the project total price
        const projectTotal = document.querySelector('.total_project');
        projectTotal.innerHTML = (projectPrice).toFixed(2);

        // Set the project total attribute for calculations
        projectTotal.setAttribute('data-total', (projectPrice).toFixed(2));

        // Update the totals
        changeInvoice();
    });
}
function deleteSelectedPaymentMethods() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.payment-method-checkbox:checked');

    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/settings/payment-methods/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Payment methods deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}
function triggerInput() {
    document.querySelector('#picture').click(); // Trigger the hidden input click event
  }
function previewImage(event) {
    const input = event.target;
    const preview = document.querySelector('.previewImage');
    const file = input.files[0];

    if (file) {
        const reader = new FileReader();

        reader.onload = function (e) {
            preview.src = e.target.result;
        };

        reader.readAsDataURL(file);
    }
}
function deleteSelectedProducts() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.product-checkbox:checked');
    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/products/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Products deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}
function deleteSelectedProjects() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.project-checkbox:checked');
    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/projects/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Projects deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}


// Attach the createProject function to the form submission event
const projectForm = document.querySelector('form[action="/projects/create"]');
if (projectForm) {
    projectForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent the default form submission
        createProject(); // Call the custom function to handle form submission
    });
}


async function createProject() {
    const projectForm = document.querySelector('form[action="/projects/create"]');

    if (projectForm) {
        const formData = new FormData(projectForm);
        // Get the customer ID
        const customer_id = document.querySelector('#customer_id-datalist .selected').dataset.id;
        // Change the customer_id to the actual id instead of the name
        formData.set('customer_id', customer_id);

        // Fetch API POST request
        try {
            const response = await fetch('/projects/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams(formData).toString(),
            });

            if (response.ok) {
                // Handle success, e.g., redirect to a new page
                window.location.href = '/projects?success';
            } else {
                // Handle errors
                logger.error('Error:', response.statusText);
            }
        } catch (error) {
            logger.error('Error:', error.message);
        }
    }
}

// Execute editProject function when on that page
const editProjectOnPage = document.querySelector('.edit-project');
if (editProjectOnPage) {
    editProjectPage()
}

function editProjectPage() {
    const customerInput = document.querySelector('#customer_id');
    const customerValue = customerInput.value;
    const customerOptions = document.querySelectorAll('#customer_id-datalist option');
    // Add the selected class to the customer value
    for (let i = 0; i < customerOptions.length; i++) {
        const customerOptionValue = customerOptions[i].value;
        if (customerOptionValue == customerValue) {
            customerOptions[i].classList.add('selected');
        }
    }
}


// Attach the editProjectForm function to the form submission event
const editProjectForm = document.querySelector('.edit-projec-form');
if (editProjectForm) {
    editProjectForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent the default form submission
        editProject(); // Call the custom function to handle form submission
    });
}

async function editProject() {
    if (editProjectForm) {
        const formData = new FormData(editProjectForm);
        // Get the customer ID
        const customer_id = document.querySelector('#customer_id-datalist .selected').dataset.id;
        // Change the customer_id to the actual id instead of the name
        formData.set('customer_id', customer_id);

        // Get URL to extract the id
        const urlString = window.location.href;
        const url = new URL(urlString);
        const id = url.pathname.split('/').pop();
        
        // Fetch API POST request
        try {
            const response = await fetch(`/projects/edit/${id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams(formData).toString(),
            });

            if (response.ok) {
                // Handle success, e.g., redirect to a new page
                window.location.href = `/projects/project/${id}?success`;
            } else {
                // Handle errors
                logger.error('Error:', response.statusText);
            }
        } catch (error) {
            logger.error('Error:', error.message);
        }
    }
}

// Show the success message
const projectOverview = document.querySelector('.project-overview');
if (projectOverview) {
    const urlString = window.location.href;
    const url = new URL(urlString);
    
    // Check if the URL contains the query parameter "?success"
    if (url.searchParams.has('success')) {
        // Execute code if the query parameter is present
        const success = document.querySelector('.alert-success');
        success.classList.remove('hidden');
    }
}
document.addEventListener('DOMContentLoaded', function () {
    const searchInput = document.getElementById('search');
    if (!searchInput) {
      return;
    }
    const searchResults = document.querySelector('.searchResultsPopup');
  
    // Function to show the search results popup
    const showSearchResults = async () => {
      const searchTerm = searchInput.value;
  
      // Fetch the search results using AJAX
      const response = await fetch(`/search?q=${encodeURIComponent(searchTerm)}`);
      const html = await response.text();
  
      // Update the search results popup
      searchResults.innerHTML = html;
      searchResults.classList.remove('hidden');
    };
  
    // Event listener for input changes
    searchInput.addEventListener('input', function () {
        showSearchResults();
    });
  
    // Event listener for Escape key
    document.addEventListener('keydown', function (event) {
      if (event.key === 'Escape') {
        searchResults.classList.add('hidden');
      }
    });
  
    // Event listener to hide the search results popup when clicking outside of it
    document.addEventListener('click', function (event) {
      if (!searchResults.contains(event.target) && event.target !== searchInput) {
        searchResults.classList.add('hidden');
      }
    });
  });
  
function deleteSelectedShippingCompanies() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.shipping-company-checkbox:checked');

    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/settings/shipping-companies/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Shipping companies deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}
function deleteSelectedTaxes() {
    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.tax-checkbox:checked');

    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch('/settings/taxes/delete-selected', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Taxes deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}
// If we're on the project overview page
if (projectOverview) {

    // Select all elements with the class "time-tracking-tr"
    const timeTrackingRows = document.querySelectorAll('.time-tracking-tr');
    const totalTimePassedEl = document.querySelector('.total-time-passed');

    // Loop through each timeTracking row
    timeTrackingRows.forEach(row => {
        // Check if the row does not have the class "stop"
        const stopEl = row.querySelector('.stop-td .stop');
        if (!stopEl) {
            // Get relevant data attributes from the row
            const timePassedEl = row.querySelector('.time-passed');

            // Initialize timePassed if not present
            var timePassed = unformatTime(timePassedEl.innerHTML) || 0;
            var totalTimePassed = unformatTime(totalTimePassedEl.innerHTML) || 0;

            // Update timePassed differently (e.g., with a timer)
            const timeTrackTimer = setInterval(() => {
                timePassed += 1;
                totalTimePassed +=1;

                // Update the timePassed element
                timePassedEl.innerHTML = formatTime(timePassed);
                totalTimePassedEl.innerHTML = formatTime(totalTimePassed);
            }, 1000);
        }
    });

}


function formatTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = seconds % 60;

    const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
    return formattedTime;
}

function unformatTime(formattedTime) {
    // Split the formatted time into hours, minutes, and seconds
    const [hours, minutes, seconds] = formattedTime.split(':').map(Number);

    // Calculate the total time in seconds
    const totalTimeInSeconds = hours * 3600 + minutes * 60 + seconds;

    return totalTimeInSeconds;
}


function deleteSelectedTimeTrackings(project_id) {

    // Select all checked checkboxes
    const checkedCheckboxes = document.querySelectorAll('.time-tracking-checkbox:checked');
    // Extract data-ids from checked checkboxes
    const selectedIds = Array.from(checkedCheckboxes).map((checkbox) => {
        return checkbox.dataset.id;
    });

    // Send a POST request with the selected data-ids
    fetch(`/projects/time-tracking/delete-selected/${project_id}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ selectedIds }),
    })
    .then(response => response.json())
    .then(data => {
        // Check for success message or error message in the response
        if (data.message === 'Time trackings deleted successfully') {
            // Perform page refresh or other actions
            location.reload(); // Reload the page
        } else {
            // Handle errors
            logger.error('Error:', data.message);
        }
    })
    .catch(error => {
        logger.error('Error:', error);
    });
}
// Request to renew the token
function renewToken() {
    // Make a POST request to your server's /renew-token endpoint
    // Include the refresh token stored in your cookies in the request
    fetch('/auth/renew-token', {
      method: 'POST',
      credentials: 'include', // Include cookies in the request
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        // Update the token cookie with the new token value
      } else {
        logger.error('Token renewal failed:', data.message);
      }
    })
    .catch(error => {
      logger.error('Token renewal error:', error);
    });
}

const loginPage = document.querySelector('.login-wrapper');
if(!loginPage) {
  setInterval(() => {
    renewToken();
  }, 1000 * access_token_expiry - (access_token_expiry / 10));
  renewToken();
}
//# sourceMappingURL=main.min.js.map